; chapter 3 (core functions in depth) notes and exercises

; MAPS - in depth

; you can use maps to map over multiple collections, running transform
; function on nth element in each

(def human-consumption [1 2 3 4])
(def critter-consumption [5 3 2 9])
(defn unify-consumption
  [human critter]
  {:human human :critter critter})
(map unify-consumption human-consumption critter-consumption)


; you can also run multiple functions on a single collection
(def sum #(reduce + %))
(def avg #(/ (sum %) (count %)))
(defn stats
  [numbers]
  (map #(% numbers) [sum avg count]))
(stats [4 13 65 32])

; you can also map over maps and extract values of a specified key
(def identities
  [{:alias "Spiderman" :real "Peter Parker"}
   {:alias "Batman" :real "Bruce Wayne"}
   {:alias "Santa" :real "Your mom"}
   {:alias "Easter Bunny" :real "Your dad"}])

(map :real identities)

; REDUCE - in depth

; used to transform a map's values
(reduce (fn [result [k v]]
          (assoc result k (inc v)))
        {}
        {:max 30 :min 20})

; notice what assoc does - it takes an existing map, a key, and a value - adds the key-value pair to the existing map
(assoc {:test "this"} :another "test")

; you can also use reduce to filter out key-value pairs depending on a value condition
(reduce (fn [result [k,v]]
          (if (> v 2)
            (assoc result k v)
            result))
        {}
        {:fred 1
         :bob 3
         :joe 5
         :john 2})

; CHALLENGE: try implementing map with reduce, then do the same for filter and some after you read about them

; IMPLEMENTING map using reduce

(def some-seq [1 2 3 4 5])

(defn my-map
  [function collection]
  (reduce (fn [result item]
            (conj result (function item)))
          []
          collection))

(my-map inc [1 2 3])

; implementation of filter
(defn my-filter
  [function collection]
  (reduce (fn [result item]
            (if (function item)
              (conj result item)
              result))
          []
          collection))
(my-filter #(or (= 3 %) (= 2 %)) some-seq)

; implementation of some
(defn my-some
  [function collection]
  (not (empty? (reduce
                (fn [result item]
                  (if (function item)
                    (conj result item)
                    result))
                []
                collection))))

(my-some #(= 2 %) [1 2 3])

; TAKE and DROP - both take two args - a number and a seq
; take returns a copy of the first n items in  a seq
; drop returns the last (length - n) items in a seq
; take-while and drop-while continue to take/drop until a predicate evaluates to false:
(take-while #(< % 4) some-seq)
(drop-while #(< % 4) some-seq)

; FILTER uses a boolean-returning function to filter out elements that
; do not evaluate the conditional to true:
(filter #(or (= 3 %) (= 2 %)) some-seq)

; SOME returns true or false depending on whether or not there are any items
; in the collection that return true for the provided conditional
(some #(= 2 %) some-seq) ; true
(some #(= 2 %) [1 3]) ; nil

; SORT and SORT_BY
(sort [2 3 1]) ; (1 2 3)
(sort-by count ["aaa" "b" "cc"]) ; ("b" "cc" "aaa")

; because clojure is lazy evaluated, you can create infinite sequences.
; enter REPEAT
(take 5 (repeat "another"))
